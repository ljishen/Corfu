-------------------------------------------------------------------

- HashMap<ulong, Projection> map, initially empty.
Keep the map from epoch to proj.

- List<Replica> inventory
A list of available replica associated with free ranges.

===================================================================
Functions
-------------------------------------------------------------------

Interfaces

- onPublish(new_seq_addr)
- onReport(oper, offset, replica_id, proj)
===================================================================

Operation onPublish(new_seq_addr) {
    synchronized(map) {
        Projection p = copy(map.lastValue())
        p.sequencer = new_seq_addr
        map.put(map.lastKey() + 1, p)
        return p.moffset
    }
}


// @param oper:       the 'READ' or 'WRITE' operation
// @param offset:     the faulty offset
// @param replica_id: the id of the faulty replica
// @param proj:       the projection held by the reporter
//
// @return            diff(proj) if projection updated else NULL
Operation onReport(oper, offset, replica_id, proj) {
    epoch = map.lastKey()

    Projection nproj = copy(map.get(epoch))
    range = nproj.rangeOf(offset)

    extent = nproj.extentOf(offset)
    replica_idx = extent.replicas.indexOf(replica_id)

    // Return if the faulty replica has already been removed
    if (replica_idx == -1)
        return diff(proj)

    extent.replicas.remove(replica_idx)

    // Just remove the faulty replica if in 'READ' operation
    if (oper == 'READ')
        return optimisticReturn(epoch, nproj, proj)


    new_range = copy(range)

    // Find the maximal number that less than offset
    // but should be assigned to extents[0], e.g.
    //
    // Case 1:
    // Range [2..9), faulty offset is 6. The slice point should be 5.
    // 2 5 8           2       5 8
    // 3 6      -->    3   +   6
    // 4 7             4       7
    //
    // Case 2:
    // Range [11..19), faulty offset is 13. The slice point should be 11.
    // 11 14 17           11 14 17
    // 12 15 18    -->    12 15 18
    // 13 16              13 16
    num_extents = len(range.extents)
    slice = (offset - range.from) / num_extents * num_extents + range.from

    // The offset could be the first position in any extent (Case 2 above)
    if (range.from == slice)
        addReplica(nproj, offset)
        return optimisticReturn(epoch, nproj, proj)


    // Slice the projection
    range.to = slice

    // Update the "to" addr
    for (int i = 0; i < len(range.extents); i++)
        for (int j = 0; j < len(range.extents[i].replicas); j++)
            range.extents[i].replicas[j].to = (range.to - range.from) / len(range.extents) +
                        range.extents[i].replicas[j].from

    // Insert the new_range
    new_range.from = slice
    new_range.next = range.next
    range.next = new_range

    // Provision a free replica to the new_range
    addReplica(nproj, offset)

    // Update the "from" addr
    for (int i = 0; i < len(new_range.extents); i++)
        for (int j = 0; j < len(new_range.extents[i].replicas); j++)
            new_range.extents[i].replicas[j].from += (range.to - range.from / len(new_range.extents))

    return optimisticReturn(epoch, nproj, proj)
}


Operation diff(p) {
    return diff(p, map.lastValue())
}


// @param epoch: the last known epoch
// @param nproj: the new projection
// @param oproj: the old projection
Operation optimisticReturn(epoch, nproj, oproj) {
    synchronized(map) {
        if (epoch == map.lastKey())
            // Publish the new projection
            map.put(epoch + 1, nproj)

            return diff(oproj)
        else
            return NULL
    }
}


// Add a replica to the extent corresponding to the
// offset in the projection.
Operation addReplica(p, offset) {
    extent = p.extentOf(offset)
    free_r = takeInventory(extent.replicas[0].to - extent.replicas[0].from)
    extent.replicas.add(free_r)
}


// Ensure at least one replica is satisfied in the inventory
Operation takeInventory(len) {
    for (Replica r : inventory)
        free_len = r.to - r.from
        if (free_len >= len)
            if (free_len == len)
                inventory.remove(r)
                return r
            else
                free_r = copy(r)
                free_r.to = free_r.from + len
                r.from = r.from + len
                return free_r
}

===================================================================