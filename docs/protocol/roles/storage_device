-------------------------------------------------------------------

- Projection p, initially empty but not NULL.

- HashMap<ulong, <ulong, bool>> map
Keep the map from ela to <epa, isDeleted>.

- ulong end_of_cleaned, initially -1.
The watermark before which no unwritten addresses exist.

===================================================================
Functions
-------------------------------------------------------------------

Interfaces

- onRead(offset, epoch)
- onAppend(range, epoch, offset, data)
- onTrim(range, epoch, offset, type)
===================================================================

Operation onRead(range, epoch, offset) {
    l_range = p.rangeOf(offset)
    if (l_range == NULL or l_range.epoch < range.epoch)
        replace(l_range, range)
    else
        return <err_sealed, NULL>

    if (map.contains(offset))
        if (map.get(offset).isDeleted)
            return <err_deleted, NULL>
    else
        if (offset <= end_of_cleaned)
            return <err_deleted, NULL>
        else
            return <err_unwritten, NULL>

    addr = map.get(offset).epa
    return <-1, read(addr)>
}


Operation onAppend(range, epoch, offset, data) {
    l_range = p.rangeOf(offset)
    if (l_range == NULL or l_range.epoch < range.epoch)
        replace(l_range, range)
    else
        return <err_sealed, NULL>

    if (map.containts(offset))
        if (map.get(offset).isDeleted)
            return <err_deleted, NULL>
        else
            return <err_written, NULL>
    else if (offset <= end_of_cleaned)
          return <err_deleted, NULL>

    // Hold place for this offset
    map.put(offset, NULL)

    extents = p.extentsOf(offset)
    if (extents[0] == host_network_addr)
        for (extents[1:])
            async send onAppend(offset, data, epoch)
            on timeout
                report

    addr = parse(offset)
}


Operation onTrim(range, epoch, offset, type) {

}


// (Offload)
Operation ping() {

}


// Replace the o_range with the n_range.
// Note that n_range's epoch is bigger than the o_range's.
Operation replace(o_range, n_range) {
    if (o_range != NULL and o_range.epoch > n_range.epoch)
        throw error

    if (o_range != NULL)
        // This is the case where n_range is long and o_range is
        // short. Since the number of ranges maps to a storage
        // device is relatively small, even doing full search for
        // the out-of-date ranges is cheap.
        if (n_range.to - n_range.from > o_range.to - o.range.from)
            for (Range r : p.ranges)
                if (r.from >= n_range.from and r.to <= n_range.to)
                    p.remove(r)
        else
            // This is the case where n_range is short and o_range
            // is long. We can directly replace the long range
            // with the new short range.
            p.remove(o_range)

    p.add(n_range)
}

===================================================================